[{"title":"Android SQLite 源码分析","date":"2016-12-22T11:04:58.000Z","path":"2016/12/22/Android-SQLite-源码分析/","text":"SQL 语句的执行过程我们在使用 SQLiteDatabase 的时候，一般都是使用它的提供的封装好的方法，那么这些方法的究竟做了哪些事呢？ SQLiteDatabase从最简单的insert(String table, String nullColumnHack, ContentValues values)方法来研究。在 SQLiteDatabase.java 文件中找到这个方法，非常简单，它简单粗暴地调用了insertWithOnConflict()方法。 12345678public long insert(String table, String nullColumnHack, ContentValues values) &#123; try &#123; return insertWithOnConflict(table, nullColumnHack, values, CONFLICT_NONE); &#125; catch (SQLException e) &#123; Log.e(TAG, \"Error inserting \" + values, e); return -1; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 public long insertWithOnConflict(String table, String nullColumnHack, ContentValues initialValues, int conflictAlgorithm) &#123; acquireReference(); try &#123; // 将参数拼接成 sql 语句，这里只是添加了 table // 大概是这个样子 INSERT INTO table( // 那个 CONFLICT_VALUES 先不管 StringBuilder sql = new StringBuilder(); sql.append(\"INSERT\"); sql.append(CONFLICT_VALUES[conflictAlgorithm]); sql.append(\" INTO \"); sql.append(table); sql.append('('); Object[] bindArgs = null; int size = (initialValues != null &amp;&amp; initialValues.size() &gt; 0) ? initialValues.size() : 0; if (size &gt; 0) &#123; bindArgs = new Object[size]; int i = 0; // initialValues 的 keySet 是对应的 column // 将 column 拼接上去，并按 column 的顺序 // 将参数取出保存到 bindArgs // 执行完这个循环就成了这样 // INSERT INTO table(column1,column2,... for (String colName : initialValues.keySet()) &#123; sql.append((i &gt; 0) ? \",\" : \"\"); sql.append(colName); bindArgs[i++] = initialValues.get(colName); &#125; // 添加 VALUES 子句，用'?'对参数占位 // 执行完就成了这样 // INSERT INTO table(column1,column2,...) VALUES (?,?,...) sql.append(')'); sql.append(\" VALUES (\"); for (i = 0; i &lt; size; i++) &#123; sql.append((i &gt; 0) ? \",?\" : \"?\"); &#125; &#125; else &#123; sql.append(nullColumnHack + \") VALUES (NULL\"); &#125; sql.append(')');// 创建一个 SQLiteStatment SQLiteStatement statement = new SQLiteStatement(this, sql.toString(), bindArgs); try &#123; // 调用 Statment 的 executeInsert() 方法 return statement.executeInsert(); &#125; finally &#123; statement.close(); &#125; &#125; finally &#123; releaseReference(); &#125; 这段代码这么长居然仅仅做了拼接 sql 语句的工作，其实其它的方法包括update和delete还有executeSQL都只是一个中间方法，他们都会创建一个SQLiteStatment并通过它来执行 SQL 语句，看到这里突然觉得很熟悉了，因为 JDBC 里也是这样O(∩_∩)O~ SQLiteStatment再来看SQLiteStatment，这个类是SQLiteProgram的子类，SQLiteProgram比较简单，主要是封装了下面的一些信息。 123456private final SQLiteDatabase mDatabase; // 对 SQLiteDatabase 的引用private final String mSql; // 之前拼接好的字符串private final boolean mReadOnly; // 打开方式是只读还是可写private final String[] mColumnNames; // column namesprivate final int mNumParameters; // 参数个数，其值等于 column 数private final Object[] mBindArgs; // 提供的参数，如果其个数大于 mNumParameters 会报错 接下来是SQLiteStatment中的一些代码，这段代码可以随意看看，注意他们都有一个共同点，就是都调用了getSession()方法，并调用这个session的execute方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Execute this SQL statement, if it is not a SELECT / INSERT / DELETE / UPDATE, for example * CREATE / DROP table, view, trigger, index etc. * * @throws android.database.SQLException If the SQL string is invalid for * some reason */ public void execute() &#123; acquireReference(); try &#123; getSession().execute(getSql(), getBindArgs(), getConnectionFlags(), null); &#125; catch (SQLiteDatabaseCorruptException ex) &#123; onCorruption(); throw ex; &#125; finally &#123; releaseReference(); &#125; &#125; /** * Execute this SQL statement, if the the number of rows affected by execution of this SQL * statement is of any importance to the caller - for example, UPDATE / DELETE SQL statements. * * @return the number of rows affected by this SQL statement execution. * @throws android.database.SQLException If the SQL string is invalid for * some reason */ public int executeUpdateDelete() &#123; acquireReference(); try &#123; return getSession().executeForChangedRowCount( getSql(), getBindArgs(), getConnectionFlags(), null); &#125; catch (SQLiteDatabaseCorruptException ex) &#123; onCorruption(); throw ex; &#125; finally &#123; releaseReference(); &#125; &#125; /** * Execute this SQL statement and return the ID of the row inserted due to this call. * The SQL statement should be an INSERT for this to be a useful call. * * @return the row ID of the last row inserted, if this insert is successful. -1 otherwise. * * @throws android.database.SQLException If the SQL string is invalid for * some reason */ public long executeInsert() &#123; acquireReference(); try &#123; return getSession().executeForLastInsertedRowId( getSql(), getBindArgs(), getConnectionFlags(), null); &#125; catch (SQLiteDatabaseCorruptException ex) &#123; onCorruption(); throw ex; &#125; finally &#123; releaseReference(); &#125; &#125; SQLiteSession那么这个Session又是何方神圣呢？getSession()在SQLiteProgram中是这样定义的，它调用了 SQLiteDatabase 的getThreadSession()方法。注意：这两个方法，一个是 protected，一个是包访问权限，他们都对外界隐藏！ 123456789// SQLiteStatment.javaprotected final SQLiteSession getSession() &#123; return mDatabase.getThreadSession(); &#125;// SQLiteDatabase.java SQLiteSession getThreadSession() &#123; return mThreadSession.get(); // initialValue() throws if database closed &#125; getThreadSession()方法又是调用了mThreadSession.get()方法，mThreadSession如下定义，它通过ThreadLocal来保证每个线程中只有一个SQLiteSession对象。 123456789// Thread-local for database sessions that belong to this database.// Each thread has its own database session.// INVARIANT: Immutable.private final ThreadLocal&lt;SQLiteSession&gt; mThreadSession = new ThreadLocal&lt;SQLiteSession&gt;() &#123; @Override protected SQLiteSession initialValue() &#123; return createSession(); &#125;&#125;; SQLiteSession是android.database.sqlite包下的一个public final类，不知道为什么在谷歌的 API 文档里没有这个类的文档，只能看文件里的注释了。我把文档注释保存成了 html 文档 SQLiteSession Documentation。文档的大致翻译我写在了文章的最后 点此跳转 通过这个文档我们知道，SQLiteSession是客户端与数据库交互的桥梁，现在我们来看看SQLiteSession中的execute方法 1234567891011121314151617181920 public void execute(String sql, Object[] bindArgs, int connectionFlags, CancellationSignal cancellationSignal) &#123; if (sql == null) &#123; throw new IllegalArgumentException(\"sql must not be null.\"); &#125;// 执行 BEGIN、COMMIT、ROLLBACK 等特殊操作 if (executeSpecial(sql, bindArgs, connectionFlags, cancellationSignal)) &#123; return; &#125;// 从 SQLConnectionPool 获取一个 SQLConnection// 同时会增加一个引用计数 acquireConnection(sql, connectionFlags, cancellationSignal); // might throw try &#123; // 执行 SELECT、INSERT、UPDATE、DELETE 等操作 mConnection.execute(sql, bindArgs, cancellationSignal); // might throw &#125; finally &#123; // 减少一个引用计数，至0时释放连接 releaseConnection(); // might throw &#125; &#125; SQLiteConnection上面的代码调用了SQLiteConnection的execute方法 123456789101112131415161718192021222324252627282930313233343536373839404142 public void execute(String sql, Object[] bindArgs, CancellationSignal cancellationSignal) &#123; if (sql == null) &#123; throw new IllegalArgumentException(\"sql must not be null.\"); &#125;// Operation 类用来描述一个操作，记录操作的类型、时间、异常、参数等// 在操作开始前调用 beginOperation 方法，记录开始时间// 操作结束后调用 endOperation 方法，记录结束时间// 操作失败了调用 failOperation 方法，记录异常 final int cookie = mRecentOperations.beginOperation(\"execute\", sql, bindArgs); try &#123; // 获取一个 PreparedStatment // 用了 LruCache 来缓存 PreparedStatment，用 sql 语句作为 key // 也就是说，如果是相同的 sql 语句（当然参数可以不同，即以'?'代表参数） // 系统自动就帮你复用之前的 PreparedStatment // 无需像 JDBC 里那样自己选择是否使用 PreparedStatment final PreparedStatement statement = acquirePreparedStatement(sql); try &#123; throwIfStatementForbidden(statement); // 绑定参数，这里调用了本地方法 bindArguments(statement, bindArgs); applyBlockGuardPolicy(statement); attachCancellationSignal(cancellationSignal); try &#123; // 执行这个 Statement // 这里是真的在执行了，交给 sqlite 驱动来完成 nativeExecute(mConnectionPtr, statement.mStatementPtr); &#125; finally &#123; detachCancellationSignal(cancellationSignal); &#125; &#125; finally &#123; releasePreparedStatement(statement); &#125; &#125; catch (RuntimeException ex) &#123; // 执行失败 mRecentOperations.failOperation(cookie, ex); throw ex; &#125; finally &#123; // 执行结束 mRecentOperations.endOperation(cookie); &#125; &#125; 它创建了一个PreparedStatment，调用bindArguments方法来绑定参数，完成PreparedStatment的编译。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private void bindArguments(PreparedStatement statement, Object[] bindArgs) &#123; final int count = bindArgs != null ? bindArgs.length : 0; // 之前提到过如果 bindArgs 的个数和 mNumParameters 不相同就会抛出异常 if (count != statement.mNumParameters) &#123; throw new SQLiteBindOrColumnIndexOutOfRangeException( \"Expected \" + statement.mNumParameters + \" bind arguments but \" + count + \" were provided.\"); &#125; if (count == 0) &#123; return; &#125; final long statementPtr = statement.mStatementPtr; for (int i = 0; i &lt; count; i++) &#123; final Object arg = bindArgs[i]; // 这里调用 DatabaseUtils 的 getTypeOfObject 方法来判断 arg 的类型 // getTypeOfObject 方法的代码见下文 // 得到参数的类型后，调用 native 方法来完成绑定 switch (DatabaseUtils.getTypeOfObject(arg)) &#123; case Cursor.FIELD_TYPE_NULL: nativeBindNull(mConnectionPtr, statementPtr, i + 1); break; case Cursor.FIELD_TYPE_INTEGER: nativeBindLong(mConnectionPtr, statementPtr, i + 1, ((Number)arg).longValue()); break; case Cursor.FIELD_TYPE_FLOAT: nativeBindDouble(mConnectionPtr, statementPtr, i + 1, ((Number)arg).doubleValue()); break; case Cursor.FIELD_TYPE_BLOB: nativeBindBlob(mConnectionPtr, statementPtr, i + 1, (byte[])arg); break; case Cursor.FIELD_TYPE_STRING: default: if (arg instanceof Boolean) &#123; // Provide compatibility with legacy applications which may pass // Boolean values in bind args. nativeBindLong(mConnectionPtr, statementPtr, i + 1, ((Boolean)arg).booleanValue() ? 1 : 0); &#125; else &#123; nativeBindString(mConnectionPtr, statementPtr, i + 1, arg.toString()); &#125; break; &#125; &#125;&#125; DatabaseUtils 和 Cursor 接口（不重要）DataBaseUtils里的getTypeOfObject方法如下12345678910111213141516public static int getTypeOfObject(Object obj) &#123; // 通过 instanceof 运算符来判断类型 // 分别对应 SQLite 里的 NULL、BLOB、INTEGER、REAL、TEXT 类型 if (obj == null) &#123; return Cursor.FIELD_TYPE_NULL; &#125; else if (obj instanceof byte[]) &#123; return Cursor.FIELD_TYPE_BLOB; &#125; else if (obj instanceof Float || obj instanceof Double) &#123; return Cursor.FIELD_TYPE_FLOAT; &#125; else if (obj instanceof Long || obj instanceof Integer || obj instanceof Short || obj instanceof Byte) &#123; return Cursor.FIELD_TYPE_INTEGER; &#125; else &#123; return Cursor.FIELD_TYPE_STRING; &#125;&#125; 对应的一些 TYPE 常量定义在Cursor接口中 123456789101112131415161718/* * Values returned by &#123;@link #getType(int)&#125;. * These should be consistent with the corresponding types defined in CursorWindow.h *//** Value returned by &#123;@link #getType(int)&#125; if the specified column is null */static final int FIELD_TYPE_NULL = 0;/** Value returned by &#123;@link #getType(int)&#125; if the specified column type is integer */static final int FIELD_TYPE_INTEGER = 1;/** Value returned by &#123;@link #getType(int)&#125; if the specified column type is float */static final int FIELD_TYPE_FLOAT = 2;/** Value returned by &#123;@link #getType(int)&#125; if the specified column type is string */static final int FIELD_TYPE_STRING = 3;/** Value returned by &#123;@link #getType(int)&#125; if the specified column type is blob */static final int FIELD_TYPE_BLOB = 4; 可以看出，DatabaseUtils是通过instanceof运算符来判断类型的，byte[]被当做 BLOB 类型，Float和Double都被当做 FLOAT 类型（应该是 SQLite 里的 REAL 类型），Long、Integer、Short和Byte都被当做 INTEGER 类型，其它的都是 STRING 类型（即 SQLite 里的 TEXT 类型）。 PreparedStatmentPreparedStatment只是一个对native对象的绑定，逻辑是在native层实现的 123456789101112131415161718192021222324252627282930313233343536373839/** * Holder type for a prepared statement. * * Although this object holds a pointer to a native statement object, it * does not have a finalizer. This is deliberate. The &#123;@link SQLiteConnection&#125; * owns the statement object and will take care of freeing it when needed. * In particular, closing the connection requires a guarantee of deterministic * resource disposal because all native statement objects must be freed before * the native database object can be closed. So no finalizers here. */ private static final class PreparedStatement &#123; // Next item in pool. public PreparedStatement mPoolNext; // The SQL from which the statement was prepared. public String mSql; // The native sqlite3_stmt object pointer. // Lifetime is managed explicitly by the connection. public long mStatementPtr; // The number of parameters that the prepared statement has. public int mNumParameters; // The statement type. public int mType; // True if the statement is read-only. public boolean mReadOnly; // True if the statement is in the cache. public boolean mInCache; // True if the statement is in use (currently executing). // We need this flag because due to the use of custom functions in triggers, it's // possible for SQLite calls to be re-entrant. Consequently we need to prevent // in use statements from being finalized until they are no longer in use. public boolean mInUse; &#125; 小结（附图）以SQLiteDatabase的insert操作为例，不废话，直接上图。（ps: 图片略长，可以右键查看原图。）Android 中 SQLiteDatabase 的 INSERT，UPDATE，DELETE 方法都是由 SQLiteStatment 来执行的，这几个方法仅仅做了拼接 SQL 语句，然后把参数从 ContentValues 里面取出放到一个 Object[] 类型的数组里，然后通过 SQL 语句和这个 绑定参数的数组创建一个 SQLiteStatment 的实例，再由 SQLiteStatment 来执行查询。SQLiteStatment 的 INSERT，UPDATE，DELETE 也是一个简单的封装，它会获取当前线程的 SQLiteSession 对象，将参数基本原封不动的传给它，再由 SQLiteSession 对象来查询。SQLiteSession 代表了一个数据库的会话，会话执行的时候会从数据库连接池中获取一个数据库连接（SQLiteConnection），然后数据库连接可以通过 JNI 来调用 sqlite 驱动，从而真正的执行数据库方法。因此 Android 系统提供的 SQLiteDatabase 仅仅提供了 SQL 拼接，参数绑定，并发控制的功能。 使用 SQLiteStatment 来执行 sql1234567891011121314151617181920212223private SQLiteStatement createStatement(SQLiteDatabase db) &#123; SQLiteStatement statement = db.compileStatement(sql); for (int i = 0; i &lt; values.size(); i++) &#123; DatabaseUtils.bindObjectToProgram(statement, i + 1, values.get(i)); &#125; return statement;&#125;public long performInsert(SQLiteDatabase db) &#123; long rowId = -1; db.acquireReference(); try &#123; SQLiteStatement statement = createStatement(db); try &#123; rowId = statement.executeInsert(); &#125; finally &#123; statement.close(); &#125; &#125; finally &#123; db.releaseReference(); &#125; return rowId;&#125; 这是参考 SQLiteDatabase 里的 insertWithOnConflict方法，去掉了里面拼接字符串的代码。首先要用 db.acquireReference() 方法获得 db对象的同步锁，并增加一个引用计数。然后在 try 语句块里面执行代码，用db.compileStatement(sql)方法创建一个SQLiteStatment实例，然后调用statement.bindXXX()方法来绑定参数，再直接调用executeInsert()执行。为什么要在 try 语句块里执行代码呢，因为要保证获得的资源都被释放，所以都在finally块里释放了资源。 上面的代码还运用了一个技巧，就是 Android 提供的DatabaseUtils类，里面有很多有用的方法，其中一个就是：123456789101112131415161718192021public static void bindObjectToProgram(SQLiteProgram prog, int index, Object value) &#123; if (value == null) &#123; prog.bindNull(index); &#125; else if (value instanceof Double || value instanceof Float) &#123; prog.bindDouble(index, ((Number)value).doubleValue()); &#125; else if (value instanceof Number) &#123; prog.bindLong(index, ((Number)value).longValue()); &#125; else if (value instanceof Boolean) &#123; Boolean bool = (Boolean)value; if (bool) &#123; prog.bindLong(index, 1); &#125; else &#123; prog.bindLong(index, 0); &#125; &#125; else if (value instanceof byte[])&#123; prog.bindBlob(index, (byte[]) value); &#125; else &#123; prog.bindString(index, value.toString()); &#125;&#125; 因为 SQLiteStatement 是 SQLiteProgram 的子类，所以这里可以用它来很方便地绑定参数，不需要关心参数的类型。 SQLiteSession Documentation 翻译关于数据库的会话与数据库的交互是通过 session 来执行的。Session 可以执行只读操作和读写操作。如果不执行写入操作，最好以只读方式打开一个 session ，这样数据库连接池可以优化数据库连接的分配，从而使多个只读操作可以并行执行，而读写操作就只能是串行的。 所有权和并发保证Session 对象不是线程安全的，所以用上面的方式，确保每个线程都有他们各自的 session 对象。一个线程至多含有一个数据库对象，这个约束保证了一个线程绝不会同时占用这个数据库的多个连接。由于数据库连接是有限的，如果一个线程尝试同时获得多个连接可能会导致死锁，因此只允许一个线程至多有一个会话（连接）。 事务事务（Transaction）有两种，隐式事务和显式事务。任何一个非显式事务的数据库操作，都会创建一个隐式事务，它会在操作成功后马上提交（commit）。显式事务通过beginTransaction()方法创建，一旦一个显式事务被创建，一系列的子操作会被当做这个事务的一部分来执行。结束一个事务的时候，如果事务成功，首先应该调用setTransactionSuccessful()，然后再调用endTransaction()。如果事务被标记为成功，它就会被提交，否则回滚（rolled back）。显式事务也可以嵌套，如果任何一个子事务没有被标记为成功，整个事务都会在最外层事务结束的时候回滚。为了提高并发性，一个显式事务可以通过调用yieldTransaction()来放弃执行权。如果这时有竞争使用数据库的情况，yield 会结束当前事务，提交已经完成的操作，释放数据库连接给另一个会话使用一段时间，然后又会开始一个和原事务有相同属性的事务。因为 yield 而提交的改变不能被滚回。当事务开始的时候，客户端可以提供一个SQLiteTransactionListener来监听事务有关的通知。推荐的使用方式： 1234567891011121314// First, begin the transaction.session.beginTransaction(SQLiteSession.TRANSACTION_MODE_DEFERRED, 0);try &#123; // Then do stuff... session.execute(\"INSERT INTO ...\", null, 0); // As the very last step before ending the transaction, mark it successful. session.setTransactionSuccessful();&#125; finally &#123; // Finally, end the transaction. // This statement will commit the transaction if it was marked successful or // roll it back otherwise. session.endTransaction();&#125; 数据库连接一个SQLDatabase可以同时有多个活动的会话，每个会话在请求数据库的时候都必须获得和释放数据库连接，如果所有连接都被占用，一些会话的事务就会被阻塞直到有可用的连接。一个会话仅在开始事务的时候获得一个连接，事务结束后必须释放。这一特性允许一个有限的数据库连接池里的连接被多个会话高效的共享，只要他们不是全部都在同一时间执行数据库事务。 响应由于数据库连接是有限的，而一个会话会在执行一整个事务的时间内占用一个连接，保持事务有一个较小的规模非常重要。尤其是执行读写操作的事务，因为他们会阻塞其它的事务执行。执行一个耗时事务的时候，考虑每隔一段时间使用yieldTransaction。另一个非常重要的方面是，事务占用太多时间可能导致 UI 线程无响应。即使事务是在后台执行，用户也会很反感事务执行的那几秒里空荡荡的 UI 界面。 可重入（Reentrance）这个类必须容忍重入性的 SQLite 操作调用，因为触发器有可能调用自定义的 SQLite 函数来执行额外的查询。这句话啥意思呢，就是说这个类里的方法必须满足可重入性，就是在一个方法还没执行完毕的时候，它可以被再次调用，且不影响先前的结果。造成这种情况的可能原因是你自定义了一个触发器，它在触发的时候又调用了这个方法。 （未完待续～）","categories":[{"name":"Android","slug":"Android","permalink":"http://WqyJh.github.io/categories/Android/"}],"tags":[{"name":"SQLite","slug":"SQLite","permalink":"http://WqyJh.github.io/tags/SQLite/"}]},{"title":"设计模式","date":"2016-12-20T11:37:14.000Z","path":"2016/12/20/设计模式/","text":"单例模式静态实例方式1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton() &#123;&#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 这种实现方法有一个很大的缺点，在类加载的时候 instance 就会被实例化，即使加载器是静态的。因此对于资源密集，配置开销比较大的单例更合理的做法是将实例化推迟到使用它的时候。即懒加载。 懒加载单例（线程不安全版）12345678910public class LazySingleton &#123; private static LazySingleton instance = null; private LazySingleton() &#123;&#125; public static LazySingleton getInstance() &#123; if (instance == null) &#123; instance = new LazySingleton(); &#125; return instance; &#125;&#125; 这种方式用到了懒加载，将实例化推迟到了使用的时候，但是当多个线程同时调用getInstance()的时候，就有可能创建多个实例。 懒加载单例（线程安全版）为了解决上面的的问题，可以将getInstance()方法设置为同步方法（synchronized）。123456public static synchronized LazySingleton getInstance() &#123; if (instance == null) &#123; instance = new LazySingleton(); &#125; return instance;&#125; 但是这样虽然做到了线程安全，解决了多实例的问题，但是它并不高效。因为任何时候只能有一个线程调用getInstance()方法，其它线程都会阻塞。 双重检验锁双重检验锁模式（double checked locking pattern）是一种同步块加锁的方法。因为会有两次检查instance == null，一次是在同步块外，一次是在同步块内。这样做是因为可能会有多个线程一起进入同步块外的检查，但是只有一个线程才能进入同步块内，这样就保证了多个线程只生成一个实例，而多个线程又能同时获得实例。12345678910public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance;&#125; 这段代码还有一些问题，因为instance = new Singleton()并不是一个原子操作，在 JVM 中这行代码大概做了 3 件事： 给 instance 分配内存 调用 Singleton 的构造方法来初始化成员变量 将 instance 指向对象分配的内存空间 但是在 JVM 的即时编译器中存在指令重排序的优化。所以上面的第二步和第三步的顺序不能保证，如果第三步比第二步先执行，这时 instance 就不为空了，如果有线程这时调用了 getInstance()方法，就会跳过外层检查，直接得到实例，用该实例访问成员变量就会出错。 关于指令重排序: http://ifeve.com/jvm-memory-reordering/ 解决方案就是吧 instance 变量声明成volatile。1private volatile static Singleton instance; 这里使用 volatile 的原因是 volatile 声明的变量会禁止指令重排序优化。但是 Java 5 以前的版本存在内存缺陷，不能避免指令重拍序。 饿汉式（唯一静态变量）饿汉式单例是指单例类在被加载的时候，唯一实例就已经被创建。将单例的实例声明为static和final变量，在类加载的时候就会初始化，所以创建实例是线程安全的，不需要synchronized和instance == null的检验了。123456789public class Singleton&#123; private static final Singleton instance = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 但是这种方式也有缺陷，getInstance()方法不是由外部调用，无法传入参数来初始化，而且也没有懒加载。 静态内部类123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 这种方法即简洁明了地保证了线程安全，又有懒加载的特性，因为只有在第一次调用getInstance()方法的时候，会加载SingletonHolder类并初始化INSTANCE。当然，它也不能配置。 枚举 Enum单元素的枚举类型已经成为实现 Singleton 的最佳方法。Java 的枚举类型实际上是功能齐全的类，因此可以有自己的属性和方法。Java 枚举类型的基本思想是通过公有的静态 final 域为每个枚举常量导出实例的类。用枚举实现单例非常简单，只需要编写一个包含单个元素的枚举类型即可。123456public enum Singleton &#123; instance; // fields // methods&#125;// 直接用 Singleton.instance 既可以使用 登记式单例单例模式的本质是控制实例数目，那有没有可能使实例的数目为2个、3个或其它个数呢？可以用Map来缓存实例，实现登记式单例，实例的个数可以自由的控制。大概思路如下：12345678public Instance getInstance(String key) &#123; Instance instance = map.get(key); if (Object.isNull(instance)) &#123; instance = new Instance(); map.put(key, instance); &#125; return instance;&#125; 注意这段代码并不是线程安全的，需要特别处理，可以参考懒汉式单例。 桥接模式它是一种对象结构型模式，又称为柄体 (Handle and Body) 模式或接口 (Interface) 模式。 结构桥接模式包含如下角色： Abstraction：抽象类，持有一个Implementor的实例 RefinedAbstraction：扩充抽象类 Implementor：实现类接口 ConcreteImplementor：具体实现类 举个栗子假设有一台打印机可以彩色打印也可以黑白打印，可以单面打印也可以双面打印，要实现这台打印机的控制流程，应该怎么做？ 一种思路建立一个抽象接口Printer，然后实现彩色打印和黑白打印的功能，再在彩色答应和黑白打印的基础上增加单面打印和双面打印的功能。这样做是可行的，Java 的 IO 库就是这么做的，定义一个Stream接口，再派生出InputStream和OutputStream，然后又派生出BufferedInputStream和BufferedOutputStream还有FileInputStream等等。但仔细想想就会发现这对程序员简直是一个噩梦，如果这时候新增一个打印照片的功能呢。真棒，我们又写了两个类！如果再增加一种打印呢，比如说雾面打印（扯）？每增加一个功能就要多写两个类，如果除了单页和双页还有别的方式呢？Java IO 库中这么写是因为 Input 和 Output 不可避免的是两个对立的操作（也许只写一个流，通过改变方向来实现 Input / Output 也可以，但这样会损失代码的语义，还有可能影响性能，毕竟 IO 操作是非常注重性能的）。而且 IO 仅有 Input / Output 这两种操作，那么其中一个维度的控件大小就已经确定为二了，所以每增加一个流的实现要增加两个类。但是我们现在面临的具体问题是，两个维度都有可能发生变化，以这种结构来写，我们将要实现N * M个类，维护的代价还是相当大的，而且不同的实现类可能有很多代码重复，比如ColoredPrinter的子类就都要调用父类的方法来实现彩色打印，然后再执行自己的业务代码。 解决方案用桥接模式来重构吧！上图中Printer是一个抽象类，print()是抽象方法。这样改进后，每增加一种颜色方案时，只需增加一个Printer的实现类，每增加一种页面方案的时候只需增加一个PrinterImpl的实现类，大大减少了要维护的代码量。123456789// 彩色单面打印Printer coloredSinglePrinter = new ColoredPrinter();coloredSinglePrinter.setPrinterImpl(new SinglePrinter());coloredSinglePrinter.print();// 黑白双面打印Printer blackDoublePrinter = new BlackPrinter();blackDoublePrinter.setPrinterImpl(new DoublePrinter());blackDoublePrinter.print(); 应用大部分的跨平台 SDK 都是桥接模式的应用，例如 JDBC、OpenGL、游戏引擎等。他们提供的 API 接口就是桥接模式中的Abstraction，在各个平台上的实现就是对Implementor的具体实现，我们在使用的时候，只需要获得一个Abstraction的实例，然后调用实例的operation()就可以完成我们的业务逻辑了。就拿 JDBC 来说，JDBC API 对应着Abstraction，而 JDBC Driver 就是Implementor接口，各个数据库提供商提供的数据库驱动就是这一接口的具体实现。我们使用 JDBC 的时候，是针对 JDBC API 编程，即客户端只与Abstraction交互。图中的RefinedAbstraction是对Abstraction的扩展。说的具体一点就是 JDBC 里的Connection和Statment对应着桥接模式里的Abstraction，PreparedStatment可以视作一个RefinedAbstraction。 本质桥接模式的应用非常广泛，其本质就是面向抽象编程。利用组合关系而不是继承，分离多个维度的抽象和实现部分，使他们都可以独立变化。如果做一件事有两个维度的变化量（比如说两个团队开发的两个组件之间需要交互），那么不要考虑，就用桥接模式吧！当然多个维度也是可以的，不过要根据业务逻辑来决定接口之间的关联关系。我们在开发中使用的第三方依赖，如果它还依赖与其它第三方库，这就可以视为一个桥接链。如果我们使用的两个依赖，他们之间也有依赖关系，就是一个多维度的桥接关系，我们只面向库提供的接口编程，一个库内部实现的改变不会影响我们编码，也不会影响另一个库（前提是不改变接口），一个库扩展出新的功能，我们和第三方都只要做很小的改动就能使用这个功能，而且不会影响原有代码的稳定。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://WqyJh.github.io/categories/设计模式/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://WqyJh.github.io/tags/Java/"}]},{"title":"UML建模","date":"2016-11-18T15:22:06.000Z","path":"2016/11/18/UML建模/","text":"用例图 UseCases are a means to capture the requirements of systems, i.e., what systems are supposed to do. The key concepts specified in this clause are Actors, UseCases, and subjects. Each UseCase’s subject represents a system under consideration to which the UseCase applies. Users and any other systems that may interact with a subject are represented as Actors.A UseCase is a specification of behavior. An instance of a UseCase refers to an occurrence of the emergent behavior that conforms to the corresponding UseCase. Such instances are often described by Interactions. @引自uml.org 用例是描述系统需求的一种手段，即，什么系统应该做什么。它包含的关键概念有Actors（参与者），UseCases（用例）和Subjects（主体）。 Subject代表一个包含多个用例的系统。用户和任何其它系统在与Subject交互时视为Actor。 UseCase是一个具体的行为。 UseCase的实例指的是指发生的相应行为。这样的实例通常由交互描述。 另有Subject的解释：A subject is a classifier (including subsystem, component, or even class) representing a business, software system, physical system or device under analysis, design, or consideration, having some behavior, and to which a set of use cases applies. 用例图（Use Case Diagram）是行为图（Behavior Diagrams）的一种，主要用来描述用户、需求、系统功能单元之间的关系，通常在需求分析过程中建立。 包含元素 Actor（参与者）与应用程序或系统进行交互的用户、组织或外部系统。用一个小人表示。 Use Case（用例）外部可见的系统功能，对系统服务进行描述。用一个椭圆表示。 Subject（主体）表示包含一个或多个用例的系统。用一个矩形方框表示。 关系 association（关联关系）用例图中只允许Actor和UseCase间的双向关联，即一条没有箭头的线。线的两端可以有数字，表示关联关系的多重性。有些建模软件、作图软件只有带箭头的线，所以在很多文章里看到的都是用带箭头的线表示关联关系 include（包含关系）两个用例间的包含关系用一个单箭头虚线表示，由包含者指向被包含者。线有一个&lt;&lt;include&gt;&gt;标签。 extend （扩展关系）扩展关系指用例功能的延伸，相当于为其提供一个附加功能。 两个用例间的扩展关系用一个单箭头虚线表示，由扩展指向被扩展。线有一个&lt;&lt;extend&gt;&gt;标签。 generalization （泛化关系）与类图中的泛化（继承）关系相同，可以是Actor之间的泛化关系，也可以是UseCase之间的泛化关系。由一个单向三角实线箭头表示，箭头指向基类。 参考： https://www.ibm.com/developerworks/cn/rational/r-usecase-atm/ http://www.uml-diagrams.org/use-case-diagrams.html http://blog.csdn.net/tianhai110/article/details/6369762 uml.org","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://WqyJh.github.io/categories/软件工程/"}],"tags":[{"name":"UML","slug":"UML","permalink":"http://WqyJh.github.io/tags/UML/"}]},{"title":"有趣的Linux命令","date":"2016-10-03T08:18:34.000Z","path":"2016/10/03/有趣的Linux命令/","text":"ag又名the silver searcher，是一个高效的代码搜索命令，当你要在大量代码中查找某个字符串时，ag一定是一个好帮手。12345#在当前目录下的所有文件里查找含有“word”的内容。$ ag word#grep命令实现相同效果。$ grep \"word\" * -R ag, ack, grep效率对比 aria2c下载神器，通过网盘助手之类的浏览器扩展导出aria2下载命令，可以突破百度网盘限速，日常使用也很赞哦1234567# -c 表示启用断点续传# -s10 表示将文件分成10部分，多线程多连接下载# -k1M 表示文件分块的最小值为1M# -x10表示单台服务器的最大连接数# -o \"filenam\" 表示把下载的文件命名为filename# “link” 可以是uri，magnet，torrent_file等$ aria2c -c -s10 -k1M -x10 -o ”filename\" \"link\" tree以树状图形式列出目录内容 1234# -L 2 表示目录树的最大深度# -I exclude_pattern 匹配正则字符串的文件或目录不予显示# -P include_pattern 只显示匹配正则字符串的文和或目录$ tree -L 2 -I exclude_pattern [-P include_pattern] path scpscp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令，有了这条命令就可以不用配置ftp来传文件了，直接用ssh远程登录的配置。 12345678# -r 递归地复制目录中所有文件# -v verbose模式，在控制台输出操作# -i identity_file 使用identity_file表示的ssh秘钥来认证身份# source 要复制的源文件# user 要登录的远程用户名# ip 远程服务器ip# dest 服务器上的目标目录$ scp -r -v -i identity_file source user@ip:dest create_apcreate_ap可以用来在支持AP的网卡上开启无线热点12345# wlan0指自己的无线网卡# eth0指自己的以太网卡# ssid是无线热点的名称# password是无线热点的密码$ sudo create_ap wlan0 eth0 ssid password 未完待续～～～","categories":[{"name":"Linux","slug":"Linux","permalink":"http://WqyJh.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://WqyJh.github.io/tags/Linux/"}]}]