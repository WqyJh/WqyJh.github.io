[{"title":"设计模式","date":"2016-12-20T11:37:14.000Z","path":"2016/12/20/设计模式/","text":"设计模式单例模式静态实例方式1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton() &#123;&#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 这种实现方法有一个很大的缺点，在类加载的时候 instance 就会被实例化，即使加载器是静态的。因此对于资源密集，配置开销比较大的单例更合理的做法是将实例化推迟到使用它的时候。即懒加载。 懒加载单例（线程不安全版）12345678910public class LazySingleton &#123; private static LazySingleton instance = null; private LazySingleton() &#123;&#125; public static LazySingleton getInstance() &#123; if (instance == null) &#123; instance = new LazySingleton(); &#125; return instance; &#125;&#125; 这种方式用到了懒加载，将实例化推迟到了使用的时候，但是当多个线程同时调用getInstance()的时候，就有可能创建多个实例。 懒加载单例（线程安全版）为了解决上面的的问题，可以将getInstance()方法设置为同步方法（synchronized）。123456public static synchronized LazySingleton getInstance() &#123; if (instance == null) &#123; instance = new LazySingleton(); &#125; return instance;&#125; 但是这样虽然做到了线程安全，解决了多实例的问题，但是它并不高效。因为任何时候只能有一个线程调用getInstance()方法，其它线程都会阻塞。 双重检验锁双重检验锁模式（double checked locking pattern）是一种同步块加锁的方法。因为会有两次检查instance == null，一次是在同步块外，一次是在同步块内。这样做是因为可能会有多个线程一起进入同步块外的检查，但是只有一个线程才能进入同步块内，这样就保证了多个线程只生成一个实例，而多个线程又能同时获得实例。12345678910public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance;&#125; 这段代码还有一些问题，因为instance = new Singleton()并不是一个原子操作，在 JVM 中这行代码大概做了 3 件事： 给 instance 分配内存 调用 Singleton 的构造方法来初始化成员变量 将 instance 指向对象分配的内存空间 但是在 JVM 的即时编译器中存在指令重排序的优化。所以上面的第二步和第三步的顺序不能保证，如果第三步比第二步先执行，这时 instance 就不为空了，如果有线程这时调用了 getInstance()方法，就会跳过外层检查，直接得到实例，用该实例访问成员变量就会出错。 关于指令重排序: http://ifeve.com/jvm-memory-reordering/ 解决方案就是吧 instance 变量声明成volatile。1private volatile static Singleton instance; 这里使用 volatile 的原因是 volatile 声明的变量会禁止指令重排序优化。但是 Java 5 以前的版本存在内存缺陷，不能避免指令重拍序。 饿汉式（唯一静态变量）饿汉式单例是指单例类在被加载的时候，唯一实例就已经被创建。将单例的实例声明为static和final变量，在类加载的时候就会初始化，所以创建实例是线程安全的，不需要synchronized和instance == null的检验了。123456789public class Singleton&#123; private static final Singleton instance = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 但是这种方式也有缺陷，getInstance()方法不是由外部调用，无法传入参数来初始化，而且也没有懒加载。 静态内部类123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 这种方法即简洁明了地保证了线程安全，又有懒加载的特性，因为只有在第一次调用getInstance()方法的时候，会加载SingletonHolder类并初始化INSTANCE。当然，它也不能配置。 枚举 Enum单元素的枚举类型已经成为实现 Singleton 的最佳方法。Java 的枚举类型实际上是功能齐全的类，因此可以有自己的属性和方法。Java 枚举类型的基本思想是通过公有的静态 final 域为每个枚举常量导出实例的类。用枚举实现单例非常简单，只需要编写一个包含单个元素的枚举类型即可。123456public enum Singleton &#123; instance; // fields // methods&#125;// 直接用 Singleton.instance 既可以使用 登记式单例单例模式的本质是控制实例数目，那有没有可能使实例的数目为2个、3个或其它个数呢？可以用Map来缓存实例，实现登记式单例，实例的个数可以自由的控制。大概思路如下：12345678public Instance getInstance(String key) &#123; Instance instance = map.get(key); if (Object.isNull(instance)) &#123; instance = new Instance(); map.put(key, instance); &#125; return instance;&#125; 注意这段代码并不是线程安全的，需要特别处理，可以参考懒汉式单例。 桥接模式它是一种对象结构型模式，又称为柄体 (Handle and Body) 模式或接口 (Interface) 模式。 结构桥接模式包含如下角色： Abstraction：抽象类，持有一个Implementor的实例 RefinedAbstraction：扩充抽象类 Implementor：实现类接口 ConcreteImplementor：具体实现类 举个栗子假设有一台打印机可以彩色打印也可以黑白打印，可以单面打印也可以双面打印，要实现这台打印机的控制流程，应该怎么做？ 一种思路建立一个抽象接口Printer，然后实现彩色打印和黑白打印的功能，再在彩色答应和黑白打印的基础上增加单面打印和双面打印的功能。这样做是可行的，Java 的 IO 库就是这么做的，定义一个Stream接口，再派生出InputStream和OutputStream，然后又派生出BufferedInputStream和BufferedOutputStream还有FileInputStream等等。但仔细想想就会发现这对程序员简直是一个噩梦，如果这时候新增一个打印照片的功能呢。真棒，我们又写了两个类！如果再增加一种打印呢，比如说雾面打印（扯）？每增加一个功能就要多写两个类，如果除了单页和双页还有别的方式呢？Java IO 库中这么写是因为 Input 和 Output 不可避免的是两个对立的操作（也许只写一个流，通过改变方向来实现 Input / Output 也可以，但这样会损失代码的语义，还有可能影响性能，毕竟 IO 操作是非常注重性能的）。而且 IO 仅有 Input / Output 这两种操作，那么其中一个维度的控件大小就已经确定为二了，所以每增加一个流的实现要增加两个类。但是我们现在面临的具体问题是，两个维度都有可能发生变化，以这种结构来写，我们将要实现N * M个类，维护的代价还是相当大的，而且不同的实现类可能有很多代码重复，比如ColoredPrinter的子类就都要调用父类的方法来实现彩色打印，然后再执行自己的业务代码。 解决方案用桥接模式来重构吧！上图中Printer是一个抽象类，print()是抽象方法。这样改进后，每增加一种颜色方案时，只需增加一个Printer的实现类，每增加一种页面方案的时候只需增加一个PrinterImpl的实现类，大大减少了要维护的代码量。123456789// 彩色单面打印Printer coloredSinglePrinter = new ColoredPrinter();coloredSinglePrinter.setPrinterImpl(new SinglePrinter());coloredSinglePrinter.print();// 黑白双面打印Printer blackDoublePrinter = new BlackPrinter();blackDoublePrinter.setPrinterImpl(new DoublePrinter());blackDoublePrinter.print(); 应用大部分的跨平台 SDK 都是桥接模式的应用，例如 JDBC、OpenGL、游戏引擎等。他们提供的 API 接口就是桥接模式中的Abstraction，在各个平台上的实现就是对Implementor的具体实现，我们在使用的时候，只需要获得一个Abstraction的实例，然后调用实例的operation()就可以完成我们的业务逻辑了。就拿 JDBC 来说，JDBC API 对应着Abstraction，而 JDBC Driver 就是Implementor接口，各个数据库提供商提供的数据库驱动就是这一接口的具体实现。我们使用 JDBC 的时候，是针对 JDBC API 编程，即客户端只与Abstraction交互。图中的RefinedAbstraction是对Abstraction的扩展。说的具体一点就是 JDBC 里的Connection和Statment对应着桥接模式里的Abstraction，PreparedStatment可以视作一个RefinedAbstraction。 本质桥接模式的应用非常广泛，其本质就是面向抽象编程。利用组合关系而不是继承，分离多个维度的抽象和实现部分，使他们都可以独立变化。如果做一件事有两个维度的变化量（比如说两个团队开发的两个组件之间需要交互），那么不要考虑，就用桥接模式吧！当然多个维度也是可以的，不过要根据业务逻辑来决定接口之间的关联关系。我们在开发中使用的第三方依赖，如果它还依赖与其它第三方库，这就可以视为一个桥接链。如果我们使用的两个依赖，他们之间也有依赖关系，就是一个多维度的桥接关系，我们只面向库提供的接口编程，一个库内部实现的改变不会影响我们编码，也不会影响另一个库（前提是不改变接口），一个库扩展出新的功能，我们和第三方都只要做很小的改动就能使用这个功能，而且不会影响原有代码的稳定。","categories":[],"tags":[]},{"title":"UML建模","date":"2016-11-18T15:22:06.000Z","path":"2016/11/18/UML建模/","text":"UML建模用例图 UseCases are a means to capture the requirements of systems, i.e., what systems are supposed to do. The key concepts specified in this clause are Actors, UseCases, and subjects. Each UseCase’s subject represents a system under consideration to which the UseCase applies. Users and any other systems that may interact with a subject are represented as Actors.A UseCase is a specification of behavior. An instance of a UseCase refers to an occurrence of the emergent behavior that conforms to the corresponding UseCase. Such instances are often described by Interactions. @引自uml.org 用例是描述系统需求的一种手段，即，什么系统应该做什么。它包含的关键概念有Actors（参与者），UseCases（用例）和Subjects（主体）。 Subject代表一个包含多个用例的系统。用户和任何其它系统在与Subject交互时视为Actor。 UseCase是一个具体的行为。 UseCase的实例指的是指发生的相应行为。这样的实例通常由交互描述。 另有Subject的解释：A subject is a classifier (including subsystem, component, or even class) representing a business, software system, physical system or device under analysis, design, or consideration, having some behavior, and to which a set of use cases applies. 用例图（Use Case Diagram）是行为图（Behavior Diagrams）的一种，主要用来描述用户、需求、系统功能单元之间的关系，通常在需求分析过程中建立。 包含元素 Actor（参与者）与应用程序或系统进行交互的用户、组织或外部系统。用一个小人表示。 Use Case（用例）外部可见的系统功能，对系统服务进行描述。用一个椭圆表示。 Subject（主体）表示包含一个或多个用例的系统。用一个矩形方框表示。 关系 association（关联关系）用例图中只允许Actor和UseCase间的双向关联，即一条没有箭头的线。线的两端可以有数字，表示关联关系的多重性。有些建模软件、作图软件只有带箭头的线，所以在很多文章里看到的都是用带箭头的线表示关联关系 include（包含关系）两个用例间的包含关系用一个单箭头虚线表示，由包含者指向被包含者。线有一个&lt;&lt;include&gt;&gt;标签。 extend （扩展关系）扩展关系指用例功能的延伸，相当于为其提供一个附加功能。 两个用例间的扩展关系用一个单箭头虚线表示，由扩展指向被扩展。线有一个&lt;&lt;extend&gt;&gt;标签。 generalization （泛化关系）与类图中的泛化（继承）关系相同，可以是Actor之间的泛化关系，也可以是UseCase之间的泛化关系。由一个单向三角实线箭头表示，箭头指向基类。 参考： https://www.ibm.com/developerworks/cn/rational/r-usecase-atm/ http://www.uml-diagrams.org/use-case-diagrams.html http://blog.csdn.net/tianhai110/article/details/6369762 uml.org","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://WqyJh.github.io/categories/软件工程/"}],"tags":[{"name":"UML","slug":"UML","permalink":"http://WqyJh.github.io/tags/UML/"}]},{"title":"有趣的Linux命令","date":"2016-10-03T08:18:34.000Z","path":"2016/10/03/有趣的Linux命令/","text":"ag又名the silver searcher，是一个高效的代码搜索命令，当你要在大量代码中查找某个字符串时，ag一定是一个好帮手。12345#在当前目录下的所有文件里查找含有“word”的内容。$ ag word#grep命令实现相同效果。$ grep \"word\" * -R ag, ack, grep效率对比 aria2c下载神器，通过网盘助手之类的浏览器扩展导出aria2下载命令，可以突破百度网盘限速，日常使用也很赞哦1234567# -c 表示启用断点续传# -s10 表示将文件分成10部分，多线程多连接下载# -k1M 表示文件分块的最小值为1M# -x10表示单台服务器的最大连接数# -o \"filenam\" 表示把下载的文件命名为filename# “link” 可以是uri，magnet，torrent_file等$ aria2c -c -s10 -k1M -x10 -o ”filename\" \"link\" tree以树状图形式列出目录内容 1234# -L 2 表示目录树的最大深度# -I exclude_pattern 匹配正则字符串的文件或目录不予显示# -P include_pattern 只显示匹配正则字符串的文和或目录$ tree -L 2 -I exclude_pattern [-P include_pattern] path scpscp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令，有了这条命令就可以不用配置ftp来传文件了，直接用ssh远程登录的配置。 12345678# -r 递归地复制目录中所有文件# -v verbose模式，在控制台输出操作# -i identity_file 使用identity_file表示的ssh秘钥来认证身份# source 要复制的源文件# user 要登录的远程用户名# ip 远程服务器ip# dest 服务器上的目标目录$ scp -r -v -i identity_file source user@ip:dest create_apcreate_ap可以用来在支持AP的网卡上开启无线热点12345# wlan0指自己的无线网卡# eth0指自己的以太网卡# ssid是无线热点的名称# password是无线热点的密码$ sudo create_ap wlan0 eth0 ssid password 未完待续～～～","categories":[{"name":"Linux","slug":"Linux","permalink":"http://WqyJh.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://WqyJh.github.io/tags/Linux/"}]}]